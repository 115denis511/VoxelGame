>>> ПРОБЛЕМЫ И ИДЕИ
-   Voxel/MarchingCubesManager.h
    -   Проблемы с отображением вариаций 11-го (или 14?) типа марширующих кубов - часть повёрнутых и зеркальных вариаций рисуются вовнутрь.
        (РЕШЕНО) Проблема была в типе 14, для зеркальноко случая были некорректно указаны вершины треугольников. Некорректный код оставлен закоментированным.
        Нужно проверить другие типы на корректность.
        -   1 - ОК!
        -   2 - ОК!
        -   3 - ОК!
        -   4 - ОК!
        -   5 - ОК!
        -   6 - ОК!
        -   7 - ОК!
        -   8 - ОК!
        -   9 - ОК!
        -   10 - ОК!
        -   11 - ОК!
        -   12 - Имееет проблемы!
        -   13 - ОК!
        -   14 - ОК!
        -   15(зерк. 9) - ОК!
        -   16(зерк. 8) - ОК!
        -   17(зерк. 3) - ОК! 
    -   Рейкаст вокселя (MarchingCubesManager::raycastVoxel) работает криво - выбранный воксель не всегда самый близкий к центру экрана.
    -   Рейкаст не работает за пределами сетки чанков. Такое поведение справедливо для осей X и Z, но для Y это может быть проблемой
        (Например если выпасть вниз за карту или залесть выше предельной высоты).
    -   При выделении генерации и обновления чанков в отдельный поток может возникнуть гонка данных - логика сущности или сцены может изменить 
        генерируемый или обновляющий меш чанк. Чтобы этого избежать нужно:
        -   Обновление чанков не должно происходить во время обновления логики и отрисовки чанков рендером. В это время должна происходить только генерация.
        -   Чанк, выделенный при генерации через ChunkGrid::allocateChunk, должен быть недоступен для изменения. Вместо становления доступным после 
            выделения он должен быть отправлен в отдельную очередь. Для простоты хранения и проверки наличия чанка сетка может хранить индекс чанка в виде 
            отрицательного числа. Такой трюк сделет чанк недоступным для изменения (см. ChunkGrid::isHaveChunk). А ЧТО ДЕЛАТЬ ЕСЛИ ИНДЕКС ЭТО НОЛЬ?
            Для некорректного индекса чанка нужно будет выделить отдельную константу (например constexpr int INVALID_ID = INT_MIN).
        -   Когда обновление чанков станет доступно созданные при генерации чанки нужно сделать доступными (применить модуль к индексам чанков в сетке) 
            через ту самую отдельную очередь.
        -   Методу ChunkGridChanger::pushToUpdateQueue нужен мютекс, так как этот метод используется при изменении вокселей игровой логикой.
        -   Изменения положения и размера чанковой сетки должны отправляться в поток обработки чанков как отложенный запрос, а не тут же выполняться как сейчас.
    -   Из полностью заполненного вокселями чанка видно все соседние чанки. Побольшей части это не должно являться проблемой, так как камера не должна находиться
        внутри фигуры заполненного вокселя. Но теоретически это может являться проблемой на границах чанков, так как если условно левый чанк пустой, а правый 
        чанк заполнен вокселями самого маленького размера(образуя фигуру стены, углублённую в правый чанк), то в таком случае камера может попасть в позицию, 
        находящуюся в правом чанке.
    -   Существует проблема из-за прилипания жидкостей к твёрдым вокселям:
        Если построить конструкцию по такой схеме
        Низ:    Верх:
        WW      WA
        SS      WA
        где S - твёрдый воксель, W - жидкий воксель, A - пустота,
        то побокам будут некорректно отображаться фигуры кубов.
-   Voxel/VoxelPositionConverter
    -   Возможно стоит сделать typedef для входных/возвращаемых значений фукнций, например typedef glm::ivec2 ChunkPosLocal; typedef glm::ivec2 ChunkPosWorld.
-   Render/AssetManager.h
    -   Model.h
        -   Сделать доступными для загрузки только файлы 3д моделей в форматах gltf и glb.
	-   Заменить библиотеку загрузки моделей ASSIMP на какую-нибуть другую, более легковесную (TinyGLTF?).
    -   TextureManager.h
        -   Метод TextureArrayRef addMixedTexture_RGB_A() и его варианты используют в качестве выбора канала для копирования в альфа канал
            итоговой текстуры маску в виде vec4. Переделать в enum.
-   Render/ShaderStorageManager & Render/UniformManager
    -   Нужно создать массив для хранения закреплённых в текущий момент буферов и использовать его для обхода лишних вызовов glBindBufferBase, если
        данный буфер уже закреплён. Сделать это нужно потому, что в судя по профайлеру некоторые вызовы glBindBufferBase могут долго выполняться.
    -   Возможно стоит избавиться от хранения в менеджерах объектов буферов, отдав их напрямую классам, которые их используют.
-   РЕФАКТОРИНГ
    -   Переделать ВСЕ классы-менеджеры из статических в синглтоны.
-   ОПЦИИ КОМПИЛЯТОРА
    -	std::ios::sync_with_stdio(false);
-   ИНКЛЮДЫ
    -	Включить define GLM_FORCE_INTRINSICS в stdafx.h, но для этого придётся убрать все модификаторы constexpr для объектов классов GLM во всём проекте.
-   РЕНДЕРИНГ
    -   Переписать математику в SphereVolume::isInFrustum с применением std::valarray (для SIMD).
    -   Реализовать постройку и перестройку BVHTree из набора объектов с применением кодов Мортона.
        -   Сортировку кодов нужно сделать через RadixSort вместо std::sort, так как для чисел она эффективней (n * кол-во разрядов vs n log n).
    -   Идея оптимизации BVHTree через "выпрямление" поддеревьев:
        Можно добавить в структуру Node два новых поля: neighbourLeft и neighbourRight являющиеся индексами левого/правого соседа (для листьев) 
        или указателями на самый левый/правый лист поддерева (для узлов).
        В данной реализации если bounding volume узла полностью находится внутри пирамиды, можно сразу перейти к обходу листьев как связного 
        списка (через neighbourLeft/neighbourRight), минуя промежуточные узлы.
    -   В ходе профайлинга работы GPU выяснилось, что процессор на этапе Scene::applyChangesPhase() очень долго ждёт конца всех отрисовок, чтобы
        сделать ShaderStorageManager::getMappedTransformsSSBO(). Возможно это происходит потому, что данный буфер используется в отрисовке. 
        Так же замечено, что загрузка данных ShaderStorageManager::pushInstancingTransformIds() с использованием 
        glNamedBufferSubData, когда буфер уже используется для рисования, НЕ вызывает задержки.
        Нужно попробовать убрать хранение матриц трансформаций из видеокарты, вернувшись к отправке матриц для каждого вызова отрисовки и посмотреть
        результат профайлинга. Вместо SSBO для хранения матриц нужно использовать инстансированный массив и glVertexAttribDivisor
        (https://habr.com/ru/articles/352962).

>>> ПЛАН
    -   Voxel/MarchingCubesManager.h
        -   Рендер воды.
        -   SIMD реализация определений типов марширующих кубов в ChunkBuilder.
        -   SIMD реализация алгоритма floodFill для системы отсечения пещер при обновлении чанка.
            https://atrufulgium.net/2024/08/21/simd-flood-fill
        -   Сделать возможность перемещения чанковой сетки со смещением чанков внутри сетки и удалением чанков вышедших за пределы сетки.
        -   Доделать алгоритм пересечения луча с воксельным полем, добавив проверку на пересечение с треугольниками марширующего куба.
        -   Добавить рейкаст водных вокселей.
    -   Привести в порядок систему компонентов.
        -   Переделать текущую систему компонентов в Entity Component System.
    -   Простейшая реализация физики и компонента физики.
    -   Интерфейс:
        -   Рендер текста
        -   Окна
        -   Текстовые метки
        -   Кнопки
        -   Чекбоксы
        -   Слайдеры
        -   Элемент изображений, способный вывести ЛЮБУЮ текстуру
    -   Система освещения
        -   Фреймбуффер геометрии.
        -   Фреймбуффер прозрачности.
        -   Скайбокс.
        -   Направленный источник света.
        -   Тень от направленного источника света.
        -   Локальные источники света.
        -   Тени от локальных источников света.
    -   Многопоточность
        -   Вынести генерацию и загрузку чанков в отдельный поток.
    -   Доработка менеджера ассетов.
        -   Анимации.
        -   Заменить библиотеку загрузки моделей ASSIMP на TinyGLTF
        -   (?)Кастомные шейдеры