>>> ПРОБЛЕМЫ И ИДЕИ
-   Voxel/MarchingCubesManager.h
    -   Проблемы с отображением вариаций 11-го (или 14?) типа марширующих кубов - часть повёрнутых и зеркальных вариаций рисуются вовнутрь.
        (РЕШЕНО) Проблема была в типе 14, для зеркальноко случая были некорректно указаны вершины треугольников. Некорректный код оставлен закоментированным.
        Нужно проверить другие типы на корректность.
        -   1 - ОК!
        -   2 - ОК!
        -   3 - ОК!
        -   4 - ОК!
        -   5 - ОК!
        -   6 - ОК!
        -   7 - ОК!
        -   8 - ОК!
        -   9 - ОК!
        -   10 - ОК!
        -   11 - ОК!
        -   12 - Имееет проблемы!
        -   13 - ОК!
        -   14 - ОК!
        -   15(зерк. 9) - ОК!
        -   16(зерк. 8) - ОК!
        -   17(зерк. 3) - ОК! 
    -   Рейкаст вокселя (MarchingCubesManager::raycastVoxel) работает криво - выбранный воксель не всегда самый близкий к центру экрана.
    -   Рейкаст не работает за пределами сетки чанков. Такое поведение справедливо для осей X и Z, но для Y это может быть проблемой
        (Например если выпасть вниз за карту или залесть выше предельной высоты).
    -   Перед реализацией вокселей воды возможно стоит переделать выделение видеопамяти под чанки.
        Можно сделать так, чтобы полностью пустые или заполненные чанки, которые не содержат рисуемых марширующих кубов, "освобождали" память
        отдавая свой ssbo/область в глобальном ssbo для чанков в пул свободных чанков.
        В случае появления в чанке рисуемого марширующего куба чанк должен брать ssbo/область глобального ssbo из пула.
        Для случаев, когда выделенной памяти будет нехватать можно оставить отдельный небольшой ssbo в который данные чанков будут загружаться
        каждый кадр (а может просто выделить эти несчастные 2 гб под воксели и не париться).
        >>> ИЛИ
        Можно отдельно хранить воксельные сетки чанков в 4 байтах на воксель и убрать вершинные данные из packedData, попутно сократив его с 8 до 4 байт.
        В VoxelTriangleData.figureId.xyz можно хранить не специфический Id запакованных данных для вершины в конкретной фигуре, а конкретный
        индекс вершины марширующего куба к которой принадлежит данная вершина и брать данные для вершины из воксельной сетки по позиции
        марширующего куба + смещение для глобального индекса вершины марширующего куба.
        (НАПОМИНАНИЕ: индекс вершины марширующего куба - это пронумерованные позиции вершин куба начиная с переднего-левого-верхнего,
        где нумерация идёт по часовой стрелке сверху вниз: 0 - перед-лево-верх, 1 - перед-право-верх, 2 - зад-право-верх, 3 - зад-лево-верх,
        4 - перед-лево-низ, 5 - перед-право-низ, 6 - зад-право-низ, 7 - зад-лево-низ)
        (НАПОМИНАНИЕ: Вершины фигуры марширующего куба находятся строго в положительных координатах и позиция 7 глобального индекса вершины марширующего куба
        соответствует позиции (0,0,0). Следовательно таблица смещений вершин марширующего куба будет выглядеть так: 
        0 - (0,1,1), 1 - (1,1,1), 2 - (1,1,0), 3 - (0,1,0), 4 - (0,0,1), 5 - (1,0,1), 6 - (1,0,0), 7 - (0,0,0))
        Подобная реализация: 
            1 - Уберет дублирование данных смежных вершин (как сейчас происходит в запакованных данных).
            2 - Позволит запаковывать в воксели данные для твёрдых материалов и воды (3 бита для толщины вокселя материала, 13 для тестуры 
            материала, 3 для толщины вокселя воды, 13 для тестуры воды).
            3 - В запакованных данных останутся только позиции для фигур, что занимают 15 бит из 32, что можно использовать для хранения двух позиций
            в одном значении. 
        Из минусов - после каждого изменения сетки чанка придётся дополнительно синхронизировать воксельную сетку в видеокарте.
        Используемая память в текущей реализации:
            чанк = 32 * 32 * 32 * 8 байт = 262144 байт
            сетка = 24 * 8 * 24 * чанк = 4608 * 262144 = 1207959552 байт = 1207 мб (без воды)
        Новый вариант:
            кол-во вокселей на оси = 32 + 1(слой копии границы соседнего чанка)
            чанк = 33 * 33 * 33 * 4(данные вокселя) + 32 * 32 * 32 * 2(запакованные данные на одну фигуру) = 143748 + 65536 = 209284 байт
            сетка = 24 * 8 * 24 * чанк = 4608 * 209284 = 964380672 байт = 964 мб (с учётом хранения данных вокселей воды)
    -   При выделении генерации и обновления чанков в отдельный поток может возникнуть гонка данных - логика сущности или сцены может изменить 
        генерируемый или обновляющий меш чанк. Чтобы этого избежать нужно:
        -   Обновление чанков не должно происходить во время обновления логики и отрисовки чанков рендером. В это время должна происходить только генерация.
        -   Чанк, выделенный при генерации через ChunkGrid::allocateChunk, должен быть недоступен для изменения. Вместо становления доступным после 
            выделения он должен быть отправлен в отдельную очередь. Для простоты хранения и проверки наличия чанка сетка может хранить индекс чанка в виде 
            отрицательного числа. Такой трюк сделет чанк недоступным для изменения (см. ChunkGrid::isHaveChunk). А ЧТО ДЕЛАТЬ ЕСЛИ ИНДЕКС ЭТО НОЛЬ?
            Для некорректного индекса чанка нужно будет выделить отдельную константу (например constexpr int INVALID_ID = INT_MIN).
        -   Когда обновление чанков станет доступно созданные при генерации чанки нужно сделать доступными (применить модуль к индексам чанков в сетке) 
            через ту самую отдельную очередь.
        -   Методу ChunkGridChanger::pushToUpdateQueue нужен мютекс, так как этот метод используется при изменении вокселей игровой логикой.
        -   Изменения положения и размера чанковой сетки должны отправляться в поток обработки чанков как отложенный запрос, а не тут же выполняться как сейчас.
    -   Для шейдера отрисовки воксельных чанков, хранящихся в едином буффере, можно переместить данные марширующих кубов из SSBO в Layout 
        (см. layout(std430, binding = 12) readonly buffer ChunkData { uvec2 packedData[]; }; в bin/Shader/marchingCubesAllInOne.vert). 
        В теории это можно сделать с помощь glVertexAttribDivisor, но тогда хранимые значения в gl_BaseVertex и gl_BaseInstance придётся
        поменять местами.
-   Voxel/VoxelPositionConverter
    -   Возможно стоит сделать typedef для входных/возвращаемых значений фукнций, например typedef glm::ivec2 ChunkPosLocal; typedef glm::ivec2 ChunkPosWorld.
-   Render/AssetManager.h
    -   Model.h
        -   Сделать доступными для загрузки только файлы 3д моделей в форматах gltf и glb.
	-   Заменить библиотеку загрузки моделей ASSIMP на какую-нибуть другую, более легковесную (TinyGLTF?).
    -   TextureManager.h
        -   Метод TextureArrayRef addMixedTexture_RGB_A() и его варианты используют в качестве выбора канала для копирования в альфа канал
            итоговой текстуры маску в виде vec4. Переделать в enum.
-   Render/ShaderStorageManager & Render/UniformManager
    -   Нужно создать массив для хранения закреплённых в текущий момент буферов и использовать его для обхода лишних вызовов glBindBufferBase, если
        данный буффер уже закреплён. Сделать это нужно потому, что в судя по профайлеру некоторые вызовы glBindBufferBase могут долго выполняться.
    -   Возможно стоит избавиться от хранения в менеджерах объектов буферов, отдав их напрямую классам, которые их используют.
-   РЕФАКТОРИНГ
    -   Переделать ВСЕ классы-менеджеры из статических в синглтоны.
-   ОПЦИИ КОМПИЛЯТОРА
    -	std::ios::sync_with_stdio(false);
-   ИНКЛЮДЫ
    -	Включить define GLM_FORCE_INTRINSICS в stdafx.h, но для этого придётся убрать все модификаторы constexpr для объектов классов GLM во всём проекте.
-   РЕНДЕРИНГ
    -   Переписать математику в SphereVolume::isInFrustum с применением std::valarray (для SIMD).
    -   Реализовать постройку и перестройку BVHTree из набора объектов с применением кодов Мортона.
        -   Сортировку кодов нужно сделать через RadixSort вместо std::sort, так как для чисел она эффективней (n * кол-во разрядов vs n log n).
    -   Идея оптимизации BVHTree через "выпрямление" поддеревьев:
        Можно добавить в структуру Node два новых поля: neighbourLeft и neighbourRight являющиеся индексами левого/правого соседа (для листьев) 
        или указателями на самый левый/правый лист поддерева (для узлов).
        В данной реализации если bounding volume узла полностью находится внутри пирамиды, можно сразу перейти к обходу листьев как связного 
        списка (через neighbourLeft/neighbourRight), минуя промежуточные узлы.
    -   В ходе профайлинга работы GPU выяснилось, что процессор на этапе Scene::applyChangesPhase() очень долго ждёт конца всех отрисовок, чтобы
        сделать ShaderStorageManager::getMappedTransformsSSBO(). Возможно это происходит потому, что данный буфер используется в отрисовке. 
        Так же замечено, что загрузка данных ShaderStorageManager::pushInstancingTransformIds() с использованием 
        glNamedBufferSubData, когда буфер уже используется для рисования, НЕ вызывает задержки.
        Нужно попробовать убрать хранение матриц трансформаций из видеокарты, вернувшись к отправке матриц для каждого вызова отрисовки и посмотреть
        результат профайлинга. Вместо SSBO для хранения матриц нужно использовать инстансированный массив и glVertexAttribDivisor
        (https://habr.com/ru/articles/352962).

>>> ПЛАН
    -   Voxel/MarchingCubesManager.h
        -   Сделать возможность перемещения чанковой сетки со смещением чанков внутри сетки и удалением чанков вышедших за пределы сетки.
        -   Доделать алгоритм пересечения луча с воксельным полем, добавив проверку на пересечение с треугольниками марширующего куба.
    -   Привести в порядок систему компонентов.
    -   Простейшая реализация физики и компонента физики.
    -   Интерфейс:
        -   Рендер текста
        -   Окна
        -   Текстовые метки
        -   Кнопки
        -   Чекбоксы
        -   Слайдеры
        -   Элемент изображений, способный вывести ЛЮБУЮ текстуру
    -   Система освещения
    -   Многопоточность