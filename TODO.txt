>>> ПРОБЛЕМЫ И ИДЕИ
-   Voxel/MarchingCubesManager.h
    -   Проблемы с отображением вариаций 11-го (или 14?) типа марширующих кубов - часть повёрнутых и зеркальных вариаций рисуются вовнутрь.
        (РЕШЕНО) Проблема была в типе 14, для зеркальноко случая были некорректно указаны вершины треугольников. Некорректный код оставлен закоментированным.
        Нужно проверить другие типы на корректность.
        -   1 - ОК!
        -   2 - ОК!
        -   3 - ОК!
        -   4 - ОК!
        -   5 - ОК!
        -   6 - ОК!
        -   7 - ОК!
        -   8 - ОК!
        -   9 - ОК!
        -   10 - ОК!
        -   11 - ОК!
        -   12 - Имееет проблемы!
        -   13 - ОК!
        -   14 - ОК!
        -   15(зерк. 9) - ОК!
        -   16(зерк. 8) - ОК!
        -   17(зерк. 3) - ОК! 
    -   Рейкаст вокселя (MarchingCubesManager::raycastVoxel) работает криво - выбранный воксель не всегда самый близкий к центру экрана.
    -   Рейкаст не работает за пределами сетки чанков. Такое поведение справедливо для осей X и Z, но для Y это может быть проблемой
        (Например если выпасть вниз за карту или залесть выше предельной высоты).
    -   Перед реализацией вокселей воды возможно стоит переделать выделение видеопамяти под чанки.
        Можно сделать так, чтобы полностью пустые или заполненные чанки, которые не содержат рисуемых марширующих кубов, "освобождали" память
        отдавая свой ssbo/область в глобальном ssbo для чанков в пул свободных чанков.
        В случае появления в чанке рисуемого марширующего куба чанк должен брать ssbo/область глобального ssbo из пула.
        Для случаев, когда выделенной памяти будет нехватать можно оставить отдельный небольшой ssbo в который данные чанков будут загружаться
        каждый кадр (а может просто выделить эти несчастные 2 гб под воксели и не париться).
    -   При выделении генерации и обновления чанков в отдельный поток может возникнуть гонка данных - логика сущности или сцены может изменить 
        генерируемый или обновляющий меш чанк. Чтобы этого избежать нужно:
        -   Обновление чанков не должно происходить во время обновления логики и отрисовки чанков рендером. В это время должна происходить только генерация.
        -   Чанк, выделенный при генерации через ChunkGrid::allocateChunk, должен быть недоступен для изменения. Вместо становления доступным после 
            выделения он должен быть отправлен в отдельную очередь. Для простоты хранения и проверки наличия чанка сетка может хранить индекс чанка в виде 
            отрицательного числа. Такой трюк сделет чанк недоступным для изменения (см. ChunkGrid::isHaveChunk). А ЧТО ДЕЛАТЬ ЕСЛИ ИНДЕКС ЭТО НОЛЬ?
            Для некорректного индекса чанка нужно будет выделить отдельную константу (например constexpr int INVALID_ID = INT_MIN).
        -   Когда обновление чанков станет доступно созданные при генерации чанки нужно сделать доступными (применить модуль к индексам чанков в сетке) 
            через ту самую отдельную очередь.
        -   Методу ChunkGridChanger::pushToUpdateQueue нужен мютекс, так как этот метод используется при изменении вокселей игровой логикой.
        -   Изменения положения и размера чанковой сетки должны отправляться в поток обработки чанков как отложенный запрос, а не тут же выполняться как сейчас.
    -   Для шейдера отрисовки воксельных чанков, хранящихся в едином буффере, можно переместить данные марширующих кубов из SSBO в Layout 
        (см. layout(std430, binding = 12) readonly buffer ChunkData { uvec2 packedData[]; }; в bin/Shader/marchingCubesAllInOne.vert). 
        В теории это можно сделать с помощь glVertexAttribDivisor, но тогда хранимые значения в gl_BaseVertex и gl_BaseInstance придётся
        поменять местами.
-   Voxel/VoxelPositionConverter
    -   Возможно стоит сделать typedef для входных/возвращаемых значений фукнций, например typedef glm::ivec2 ChunkPosLocal; typedef glm::ivec2 ChunkPosWorld.
-   Render/AssetManager.h
    -   Model.h
        -   Сделать доступными для загрузки только файлы 3д моделей в форматах gltf и glb.
	-   Заменить библиотеку загрузки моделей ASSIMP на какую-нибуть другую, более легковесную (TinyGLTF?).
    -   TextureManager.h
        -   Метод TextureArrayRef addMixedTexture_RGB_A() и его варианты используют в качестве выбора канала для копирования в альфа канал
            итоговой текстуры маску в виде vec4. Переделать в enum.
-   Render/ShaderStorageManager & Render/UniformManager
    -   Нужно создать массив для хранения закреплённых в текущий момент буферов и использовать его для обхода лишних вызовов glBindBufferBase, если
        данный буффер уже закреплён. Сделать это нужно потому, что в судя по профайлеру некоторые вызовы glBindBufferBase могут долго выполняться.
    -   Возможно стоит избавиться от хранения в менеджерах объектов буферов, отдав их напрямую классам, которые их используют.
-   РЕФАКТОРИНГ
    -   Переделать ВСЕ классы-менеджеры из статических в синглтоны.
-   ОПЦИИ КОМПИЛЯТОРА
    -	std::ios::sync_with_stdio(false);
-   ИНКЛЮДЫ
    -	Включить define GLM_FORCE_INTRINSICS в stdafx.h, но для этого придётся убрать все модификаторы constexpr для объектов классов GLM во всём проекте.
-   РЕНДЕРИНГ
    -   Переписать математику в SphereVolume::isInFrustum с применением std::valarray (для SIMD).
    -   Реализовать постройку и перестройку BVHTree из набора объектов с применением кодов Мортона.
        -   Сортировку кодов нужно сделать через RadixSort вместо std::sort, так как для чисел она эффективней (n * кол-во разрядов vs n log n).
    -   Идея оптимизации BVHTree через "выпрямление" поддеревьев:
        Можно добавить в структуру Node два новых поля: neighbourLeft и neighbourRight являющиеся индексами левого/правого соседа (для листьев) 
        или указателями на самый левый/правый лист поддерева (для узлов).
        В данной реализации если bounding volume узла полностью находится внутри пирамиды, можно сразу перейти к обходу листьев как связного 
        списка (через neighbourLeft/neighbourRight), минуя промежуточные узлы.
    -   В ходе профайлинга работы GPU выяснилось, что процессор на этапе Scene::applyChangesPhase() очень долго ждёт конца всех отрисовок, чтобы
        сделать ShaderStorageManager::getMappedTransformsSSBO(). Возможно это происходит потому, что данный буфер используется в отрисовке. 
        Так же замечено, что загрузка данных ShaderStorageManager::pushInstancingTransformIds() с использованием 
        glNamedBufferSubData, когда буфер уже используется для рисования, НЕ вызывает задержки.
        Нужно попробовать убрать хранение матриц трансформаций из видеокарты, вернувшись к отправке матриц для каждого вызова отрисовки и посмотреть
        результат профайлинга. Вместо SSBO для загрузки матриц нужно использовать инстансированный массив и glVertexAttribDivisor
        (https://habr.com/ru/articles/352962).

>>> ПЛАН
    -   Voxel/MarchingCubesManager.h
        -   После добавления в очереди на генерацию и обновление чанков нужно добавть сортировку списка по дистанции до центра.
        -   Сделать простейший генератор ландшафта.
            -   Переместить код генерации мира из MarchingCubesManager::resizeChunkGrid в MarchingCubesManager::updateChunks.
        -   Доделать алгоритм пересечения луча с воксельным полем, добавив проверку на пересечение с треугольниками марширующего куба.
    -   Привести в порядок систему компонентов.
    -   Простейшая реализация физики и компонента физики.
    -   Интерфейс:
        -   Рендер текста
        -   Окна
        -   Текстовые метки
        -   Кнопки
        -   Чекбоксы
        -   Слайдеры
        -   Элемент изображений, способный вывести ЛЮБУЮ текстуру
    -   Система освещения
    -   Многопоточность