>>> ПРОБЛЕМЫ И ИДЕИ
-   Voxel/MarchingCubesManager.h
    -   Проблемы с отображением вариаций 11-го (или 14?) типа марширующих кубов - часть повёрнутых и зеркальных вариаций рисуются вовнутрь.
        (РЕШЕНО) Проблема была в типе 14, для зеркальноко случая были некорректно указаны вершины треугольников. Некорректный код оставлен закоментированным.
        Нужно проверить другие типы на корректность.
        -   1 - ОК!
        -   2 - ОК!
        -   3 - ОК!
        -   4 - ОК!
        -   5 - ОК!
        -   6 - ОК!
        -   7 - ОК!
        -   8 - ОК!
        -   9 - ОК!
        -   10 - ОК!
        -   11 - ОК!
        -   12 - Имееет проблемы!
        -   13 - ОК!
        -   14 - ОК!
        -   15(зерк. 9) - ОК!
        -   16(зерк. 8) - ОК!
        -   17(зерк. 3) - ОК! 
    -   Рейкаст вокселя (MarchingCubesManager::raycastVoxel) работает криво - выбранный воксель не всегда самый близкий к центру экрана.
    -   Рейкаст не работает за пределами сетки чанков. Такое поведение справедливо для осей X и Z, но для Y это может быть проблемой
        (Например если выпасть вниз за карту или залесть выше предельной высоты).
    -   При изменении размера сетки чанков в большую сторону меши новых чанков не учитывают воксели соседних пограничных чанков при генерации.
        Это легко заметить, если поставить на краю крайних чанков воксели и затем увеличить размер сетки.
    -   В стандарте указано, что SSBO может имет размер МИНИМУМ 16 мб. На практике glGetIntegerv(GL_MAX_SHADER_STORAGE_BLOCK_SIZE, &size); выдаёт
        значение 2147483647 или ~2 гб для моей видеокарты (и, возможно, многих других моделей).
        Такого размера буффера хватит чтобы хранить в нём значения всех чанков в одном ssbo и рисовать ВСЕ чанки одним вызовом отрисовки.
        Но для видеокарт с меньшим максимальным размеров нужно оставить старый способ с одним ssbo для одного чанка.
    -   Перед реализацией вокселей воды возможно стоит переделать выделение видеопамяти под чанки.
        Можно сделать так, чтобы полностью пустые или заполненные чанки, которые не содержат рисуемых марширующих кубов, "освобождали" память
        отдавая свой ssbo/область в глобальном ssbo для чанков в пул свободных чанков.
        В случае появления в чанке рисуемого марширующего куба чанк должен брать ssbo/область глобального ssbo из пула.
        Для случаев, когда выделенной памяти будет нехватать можно оставить отдельный небольшой ssbo в который данные чанков будут загружаться
        каждый кадр (а может просто выделить эти несчастные 2 гб по воксели и не париться).
-   Render/AssetManager.h
    -   Model.h
        -   Сделать доступными для загрузки только файлы 3д моделей в форматах gltf и glb.
	-   Заменить библиотеку загрузки моделей ASSIMP на какую-нибуть другую, более легковесную (TinyGLTF?).
    -   TextureManager.h
        -   Метод TextureArrayRef addMixedTexture_RGB_A() и его варианты используют в качестве выбора канала для копирования в альфа канал
            итоговой текстуры маску в виде vec4. Переделать в enum.
-   РЕФАКТОРИНГ
    -   Переделать ВСЕ классы-менеджеры из статических в синглтоны.
-   ОПЦИИ КОМПИЛЯТОРА
    -	std::ios::sync_with_stdio(false);
-   ИНКЛЮДЫ
    -	Включить define GLM_FORCE_INTRINSICS в stdafx.h, но для этого придётся убрать все модификаторы constexpr для объектов классов GLM во всём проекте.
-   РЕНДЕРИНГ
    -   Переписать математику в SphereVolume::isInFrustum с применением std::valarray (для SIMD).
    -   Реализовать постройку и перестройку BVHTree из набора объектов с применением кодов Мортона.
        -   Сортировку кодов нужно сделать через RadixSort вмнсто std::sort, так как для чисел она эффективней (n * кол-во разрядов vs n log n).
    -   Идея оптимизации BVHTree через "выпрямление" поддеревьев:
        Можно добавить в структуру Node два новых поля: neighbourLeft и neighbourRight являющиеся индексами левого/правого соседа (для листьев) 
        или указателями на самый левый/правый лист поддерева (для узлов).
        В данной реализации если bounding volume узла полностью находится внутри пирамиды, можно сразу перейти к обходу листьев как связного 
        списка (через neighbourLeft/neighbourRight), минуя промежуточные узлы.
    -   В ходе профайлинга работы GPU выяснилось, что процессор на этапе Scene::applyChangesPhase() очень долго ждёт конца всех отрисовок, чтобы
        сделать ShaderStorageManager::getMappedTransformsSSBO(). Возможно это происходит потому, что данный буфер используется в отрисовке. 
        Так же замечено, что загрузка данных ShaderStorageManager::pushInstancingTransformIds() с использованием 
        glNamedBufferSubData, когда буфер уже используется для рисования, НЕ вызывает задержки.
        Нужно попробовать убрать хранение матриц трансформаций из видеокарты, вернувшись к отправке матриц для каждого вызова отрисовки и посмотреть
        результат профайлинга. Вместо SSBO для загрузки матриц нужно использовать инстансированный массив и glVertexAttribDivisor
        (https://habr.com/ru/articles/352962).

>>> ПЛАН
    -   Voxel/MarchingCubesManager.h
        -   При генерации чанков не обновляются пограничные воксели соседних чанков.
        -   Сделать простейший генератор ландшафта.
            -   Переместить код генерации мира из MarchingCubesManager::resizeChunkGrid в MarchingCubesManager::updateChunks.
        -   Доделать алгоритм пересечения луча с воксельным полем, добавив проверку на пересечение с треугольниками марширующего куба.
    -   Привести в порядок систему компонентов.
    -   Простейшая реализация физики и компонента физики.
    -   Интерфейс:
        -   Рендер текста
        -   Окна
        -   Текстовые метки
        -   Кнопки
        -   Чекбоксы
        -   Слайдеры
        -   Элемент изображений, способный вывести ЛЮБУЮ текстуру
    -   Система освещения
    -   Многопоточность