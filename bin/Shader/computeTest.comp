#version 460 core

layout( local_size_x = 31 ) in;

layout(std430, binding = 2) readonly buffer ChunkData 
{
    uvec2 packedData[];
};
struct VertexData {
    vec4 positions[8];
    uint vertexVoxelId;
    uint triangleId;
};
layout(std430, binding = 3) readonly buffer Verteces
{
    VertexData vertexData[];
};
layout(std430, binding = 4) readonly buffer InputBuffer
{
    uint commandBufferInitialIdForGroup[];
};
struct TriangleData {
    vec4 pos_TBN_tex[6];
    uvec4 figureIds;
};
layout(std430, binding = 5) buffer OutputBuffer  
{
    TriangleData triangleData[]; // 297910
};
struct DrawArraysIndirectCommand {
    uint count;
    uint instanceCount;
    uint first;
    uint baseInstance;
};
layout(std430, binding = 6) readonly buffer CommandBuffer
{
    DrawArraysIndirectCommand commandBuffer[];
};

uniform uint lastCommandId;
uniform vec3 chunkPosition;

struct UnpackedData {
    uint x;
    uint y;
    uint z;
    uint offsets[6];
    uint textureIds[6];
};

UnpackedData unpackData(uvec2 data);

// (31 * 31 * 31 * 8) * (24 * 24 * 8) = 1098215424
// (31 * 31 * 31 * 8) * (24 * 24 * 8) / 31 = 35426304
// voxelsInChunkCount = 31 * 31 * 31 = 29791
// trianglesPreChunk = voxelsInChunkCount * maxTrianglesInFigure(5) = 148955
// trianglesPreChunkDouble = 148955 * 2 = 297910
// trianglesPerWorkgroup = local_size_x(31) * maxTrianglesInFigure(5) = 31 * 5 = 155
const uint maxTrianglesInFigure = 5;
const uint trianglesPerWorkgroup = 155;
// maxWorkgroupsPerChunk = 148955 / 155 = 961

void main()
{
    uint commandBufferId = commandBufferInitialIdForGroup[gl_WorkGroupID.x];

    //uint currentInstance = commandBuffer[commandBufferId].baseInstance + baseInstanceOffsetId + gl_LocalInvocationID.x; // gl_WorkGroupSize = local_size_x
    uint currentInstance = gl_GlobalInvocationID.x;
    uint lastCommandInstance = commandBuffer[commandBufferId].baseInstance + commandBuffer[commandBufferId].instanceCount;
    // if current instance isn't inbounds of current command and current command isn't last one, then
    // try to find command that the instance belongs to
    while (lastCommandInstance <= currentInstance && commandBufferId < lastCommandId) {
        commandBufferId++;
        lastCommandInstance = commandBuffer[commandBufferId].baseInstance + commandBuffer[commandBufferId].instanceCount;
    }

    UnpackedData data = unpackData(packedData[currentInstance]);
    vec3 chunkOffset = vec3(chunkPosition.x + data.x, chunkPosition.y + data.y, chunkPosition.z + data.z);
    uint outputBufferId = currentInstance * 5;
    uint vertexId = commandBuffer[commandBufferId].first;
    uint trianglesCount = commandBuffer[commandBufferId].count / 3;

    for (int i = 0; i < trianglesCount; i++) {
        uint currentOutputBufferId = outputBufferId + i;

        // POSITIONS
        uint offsetStrength = data.offsets[vertexData[vertexId].vertexVoxelId];
        vec3 posA = vertexData[vertexId].positions[offsetStrength].xyz;
        uint vertexVoxelIdA = vertexData[vertexId].vertexVoxelId;
        vertexId++;

        offsetStrength = data.offsets[vertexData[vertexId].vertexVoxelId];
        vec3 posB = vertexData[vertexId].positions[offsetStrength].xyz;
        uint vertexVoxelIdB = vertexData[vertexId].vertexVoxelId;
        vertexId++;

        offsetStrength = data.offsets[vertexData[vertexId].vertexVoxelId];
        vec3 posC = vertexData[vertexId].positions[offsetStrength].xyz;
        uint vertexVoxelIdC = vertexData[vertexId].vertexVoxelId;
        vertexId++;

        // NORMAL
        vec3 edge_A = posB - posA;
        vec3 edge_B = posC - posA;
        vec3 normal = normalize(cross(edge_A, edge_B));

        // TEXTURE COORDS
        // get from https://stackoverflow.com/questions/8705201/troubles-with-marching-cubes-and-texture-coordinates
        vec3 normAbs = vec3(abs(normal.x), abs(normal.y), abs(normal.z));
        vec2 uvs[3];
        if (normAbs.x >= normAbs.z && normAbs.x >= normAbs.y) { // x plane
            uvs[0] = vec2(posA.z, posA.y);
            uvs[1] = vec2(posB.z, posB.y);
            uvs[2] = vec2(posC.z, posC.y);
        }
        else if (normAbs.z >= normAbs.x && normAbs.z >= normAbs.y) { // z plane
            uvs[0] = vec2(posA.x, posA.y);
            uvs[1] = vec2(posB.x, posB.y);
            uvs[2] = vec2(posC.x, posC.y);
        }
        else if (normAbs.y >= normAbs.x && normAbs.y >= normAbs.z) { // y plane
            uvs[0] = vec2(posA.x, posA.z);
            uvs[1] = vec2(posB.x, posB.z);
            uvs[2] = vec2(posC.x, posC.z);
        }

        // TANGENT, BITANGENT
        vec2 deltaUV_A = vec2(uvs[1].x - uvs[0].x, uvs[1].y - uvs[0].y);
        vec2 deltaUV_B = vec2(uvs[2].x - uvs[0].x, uvs[2].y - uvs[0].y);
        float f = 1.0f / (deltaUV_A.x * deltaUV_B.y - deltaUV_B.x * deltaUV_A.y);

        vec3 tangent = vec3(
            f * (deltaUV_B.y * edge_A.x - deltaUV_A.y * edge_B.x),
            f * (deltaUV_B.y * edge_A.y - deltaUV_A.y * edge_B.y),
            f * (deltaUV_B.y * edge_A.z - deltaUV_A.y * edge_B.z)  
        );
        tangent = normalize(tangent);

        vec3 bitangent = cross(normal, tangent);

        // STORE DATA
        triangleData[currentOutputBufferId].pos_TBN_tex[0] = vec4(
            posA.x + chunkOffset.x, 
            posA.y + chunkOffset.y, 
            posA.z + chunkOffset.z, uvs[0].x
        );
        triangleData[currentOutputBufferId].pos_TBN_tex[1] = vec4(
            posB.x + chunkOffset.x, 
            posB.y + chunkOffset.y, 
            posB.z + chunkOffset.z, uvs[0].y
        );
        triangleData[currentOutputBufferId].pos_TBN_tex[2] = vec4(
            posC.x + chunkOffset.x, 
            posC.y + chunkOffset.y, 
            posC.z + chunkOffset.z, uvs[1].x
        );
        triangleData[currentOutputBufferId].pos_TBN_tex[3] = vec4(tangent,   uvs[1].y);
        triangleData[currentOutputBufferId].pos_TBN_tex[4] = vec4(bitangent, uvs[2].x);
        triangleData[currentOutputBufferId].pos_TBN_tex[5] = vec4(normal,    uvs[2].y);

        triangleData[currentOutputBufferId].figureIds = uvec4(vertexVoxelIdA, vertexVoxelIdB, vertexVoxelIdC, 0);
    }
}

UnpackedData unpackData(uvec2 data)
{
    UnpackedData unpaked;

    unpaked.x = (data[0] >> 25) & 31; // 31 = 0b11111
    unpaked.y = (data[0] >> 20) & 31; // 31 = 0b11111
    unpaked.z = (data[0] >> 15) & 31; // 31 = 0b11111
    unpaked.offsets[0] = (data[0] >> 12) & 7; // 7 = 0b111;
    unpaked.offsets[1] = (data[0] >> 9) & 7; // 7 = 0b111;
    unpaked.offsets[2] = (data[0] >> 6) & 7; // 7 = 0b111;
    unpaked.offsets[3] = (data[0] >> 3) & 7; // 7 = 0b111;
    unpaked.offsets[4] = data[0] & 7; // 7 = 0b111;

    unpaked.offsets[5] = (data.y >> 28) & 7; // 7 = 0b111;
    unpaked.textureIds[0] = (data.y >> 21) & 127; // 127 = 0b1111111;
    unpaked.textureIds[1] = (data.y >> 14) & 127; // 127 = 0b1111111;
    unpaked.textureIds[2] = (data.y >> 7) & 127; // 127 = 0b1111111;
    unpaked.textureIds[3] = data.y & 127; // 127 = 0b1111111

    unpaked.textureIds[4] = unpaked.textureIds[2];
    unpaked.textureIds[5] = unpaked.textureIds[3];

    return unpaked;
}